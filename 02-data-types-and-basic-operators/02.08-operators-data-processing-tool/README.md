## Python как калькулятор

Теперь мы покажем вам совершенно новую сторону функции `print()`. Вы уже знаете, что функция может показать вам значения литеральных констант, переданных ей аргументами.

На самом деле, Python может сделать что-то большее. Посмотрите на фрагмент:

```python
print(2 + 2)
```  

Повторите код в редакторе и запустите его. Можете ли вы угадать вывод?

Вы должны увидеть цифру четыре. Не стесняйтесь экспериментировать с другими операторами.

Вы только что обнаружили, что Python можно использовать как калькулятор. Не очень удобный и, конечно, не карманный, но, тем не менее, калькулятор.

Если говорить об этом серьезно, то мы сейчас переходим в область **операторов** и **выражений**.


## Основные операторы

**Оператор** - это символ языка программирования, который может работать со значениями.

Например, как и в арифметике, знак `+` (плюс) является оператором, который может **сложить** два числа, давая результат сложения.

Однако не все операторы Python столь же очевидны, как знак плюс, поэтому давайте рассмотрим другие некоторые операторы, доступные в Python, и объясним, какие правила определяют их использование и как интерпретировать выполняемые ими операции..

Мы начнем с операторов, связанных с наиболее широко распознаваемыми арифметическими операциями:

`+`, `-`, `*`, `/`, `//`, `%`, `**`

Порядок их появления не случаен. Мы поговорим об этом подробнее, как только обсудим их все.

**Обратите внимание**: данные и операторы при соединении образуют **выражения**. Самым простым выражением является сама литеральная константа.


## Арифметические операторы: возведение в степень

Знак `**` (двойная звездочка) является оператором **возведения в степень** (степень). Левый аргумент это **основание**, а правый - **экспонента**.

Классическая математика предпочитает написание с верхним индексом, например **2<sup>3</sup>**. Чистые текстовые редакторы не принимают это, поэтому вместо этого Python использует `**` например, `2 ** 3`.

Посмотрите на примеры в окне редактора.

```python
print(2 ** 3)
print(2 ** 3.)
print(2. ** 3)
print(2. ** 3.)
```

**Примечание**: в примерах двойные звездочки окружены пробелами. Это не обязательно, но улучшает **читабельность** кода.

В примерах показана очень важная особенность практически всех **числовых операторов Python**.

Запустите код и внимательно посмотрите на результаты, которые он выдает. Вы видите здесь какую-то закономерность?

**Обратите внимание**: на основе этого результата можно сформулировать следующие правила:

*   когда **оба** `**` аргумента являются целыми числами, результат также является целым числом;
*   когда **хотя бы один** `**` является аргументом с плавающей точкой, результат также является плавающей точкой.

Это важное различие, которое нужно запомнить.


## Арифметические операторы: умножение

Знак `*` (звездочка) является оператором **умножения**.

Запустите приведенный ниже код и убедитесь, что наше правило умножения для _числа с плавающей точкой и целого_ все еще работает.

```python
print(2 * 3)
print(2 * 3.)
print(2. * 3)
print(2. * 3.)
```  


## Арифметические операторы: деление

Знак `/` (косая черта) является оператором **деления**.

Значение перед косой чертой - это **делимое**, значение за косой чертой **делитель**.

Запустите приведенный ниже код и проанализируйте результаты.

```python
print(6 / 3)
print(6 / 3.)
print(6. / 3)
print(6. / 3.)
```  

Здесь вы должны увидеть, что есть исключение из правила.

**Результат, полученный оператором деления, всегда является плавающим**, независимо от того, кажется ли результат на первый взгляд плавающим: `1/2`, или если оно выглядит как чистое целое число: `2/1`.

Это проблема? Да. Иногда случается, что вам действительно нужно деление, которое дает целочисленное значение, а не число с плавающей точкой.

К счастью, Python может помочь вам в этом.


## Арифметические операторы: целочисленное деление

Знак `//` (двойная косая черта) является оператором **целочисленного деления**. Он отличается от стандартного оператора `/` двумя деталями:

*   в его результате отсутствует дробная часть - он отсутствует (для целых чисел) или всегда равен нулю (для чисел с плавающей запятой); это означает, что **результаты всегда округляются**;
*   он соблюдает правило _целых и "плавающих" чисел_.

Запустите приведенный ниже пример и посмотрите результаты:

```python
print(6 // 3)
print(6 // 3.)
print(6. // 3)
print(6. // 3.)
```  

Как видите, _целочисленное деление на целое число_ дает **целочисленный результат**. Все остальные случаи производят "плавающие" числа.

Давайте сделаем несколько более сложных тестов.

Посмотрите на следующий фрагмент:

```python
print(6 // 4)
print(6. // 4)  
```

Представьте, что мы использовали `/` вместо `//` - можете ли вы предсказать результаты?

Да, это будет `1.5` в обоих случаях. Это понятно.

Но каких результатов деления мы должны ожидать при использовании `//`?

Запустите код и проверьте сами.

Мы получаем два значения - одно целое и одно с плавающей точкой.

Результат целочисленного деления всегда округляется до ближайшего целочисленного значения, которое меньше реального (не округленного) результата.

Это очень важно: **округление всегда идет к меньшему целому числу**.

Посмотрите на приведенный ниже код и попробуйте спрогнозировать результаты еще раз:

```python
print(-6 // 4)
print(6. // -4)
```  

**Примечание**: некоторые значения являются отрицательными. Как это повлияет на результат?

Результат - две отрицательные пары. Реальный (не округленный) результат равен `-1.5` в обоих случаях. Тем не менее результаты являются предметами округления. **Округление до меньшего целочисленного значения**, а меньшее целочисленное значение равно `-2`,следовательно: `-2` и `-2.0`.

**Примечание**: Целочисленное деление также можно назвать **нижним делением**. Вы обязательно встретите этот термин в будущем.


## Операторы: остаток (по модулю)

Следующий оператор является довольно своеобразным, потому что он не имеет эквивалента среди традиционных арифметических операторов.

Его графическое представление в Python - это знак `%` (процент), который может показаться немного запутанным.

Попробуйте представить это как косую черту (оператор деления), сопровождаемую двумя забавными кружочками.

Результатом оператора является **остаток после целочисленного деления**.

Другими словами, это значение, оставшееся после деления одного значения на другое для получения целочисленного отношения.

**Примечание**: оператор иногда называется **по модулю** в других языках программирования.

Взгляните на фрагмент - попытайтесь предсказать его результат, а затем запустите его:

```python
print(14 % 4)  
```

Вы увидите, что результат 2. Объясним как это получилось:

* `14 // 4` равно `3` → целых **в частном**;
* `3 * 4` равно `12` → **в результате умножения частного и делителя**;
* `14 - 12` равно `2` → - это **остаток**.

Этот пример несколько сложнее:

```python
print(12 % 4.5)
```  

Каков же результат?

<details><summary>Проверка</summary>

`3.0` - не `3`, а `3.0` (правило работает: `12 // 4.5` равно `2.0`; `2.0 * 4.5` равно `9.0`; `12 - 9.0` равно `3.0`)

</details>
  

## Операторы: как нельзя делить

Как вы, наверное, знаете, **делить на ноль нельзя**.

Не пытайтесь:

* выполнить деление на ноль;
* выполнить целочисленное деление на ноль;
* найти остаток от деления на ноль.


## Операторы: сложение

Оператор **сложение** - это знак `+` (плюс), который полностью соответствует математическим стандартам.

Опять же, взгляните на фрагмент программы ниже:

```python
print(-4 + 4)
print(-4. + 8)
```  

В результате не должно быть ничего удивительного. Запустите код, чтобы проверить его.


## Оператор вычитания, унарные и бинарные операторы

Оператор **вычитания**, очевидно, является знаком `-` (минус), хотя следует отметить, что этот оператор также имеет другое значение - **он может изменить знак числа**.

Это прекрасная возможность представить очень важное различие между **унарными** и **бинарными** операторами.

В вычитающих выражениях оператор минус **ожидает два аргумента**: левый (**уменьшаемое** в арифметических терминах) и правый (**вычитаемое**).

По этой причине оператор вычитания считается одним из бинарных операторов, так же как операторы сложения, умножения и деления.

Но оператор минус можно использовать по-другому (унарно) - взгляните на последнюю строку фрагмента ниже:

```python
print(-4 - 4)
print(4. - 8)
print(-1.1)
```  

Кстати, есть также унарный оператор `+`. Вы можете использовать это так:

```python
print(+2)
```  

Оператор сохраняет знак своего единственного аргумента - правого.

Хотя такая конструкция синтаксически правильна, ее использование не имеет особого смысла, и было бы трудно найти хорошее применение для этого.

Посмотрите на фрагмент выше - можете ли вы угадать его вывод?


## Операторы и их приоритеты

До сих пор мы рассматривали каждого оператора так, как будто он не имеет связи с остальными. Очевидно, что такая идеальная и простая ситуация является редкостью в реальном программировании.

Кроме того, вы очень часто найдете более одного оператора в одном выражении, и тогда всё уже не так просто.

Рассмотрим следующее выражение:

```
2 + 3 * 5
```  

Вы, наверное, помните из школы, что **сначала надо выполнить умножение, а затем сложение**.

Вы наверняка помните, что сначала вы должны умножить 3 на 5, оставив 15 в уме, затем добавить его к 2, получив, таким образом, результат 17.

Явление, которое заставляет некоторых операторов действовать раньше других, известно как **иерархия приоритетов**.

Python точно определяет приоритеты всех операторов и предполагает, что операторы с более высоким приоритетом выполняют свои операции перед операторами с более низким приоритетом.

Итак, если вы знаете, что `*` имеет более высокий приоритет, чем `+`, вычисление окончательного результата должно быть очевидным.


## Операторы и их порядок действий

**Ассоциативность** определяет порядок вычислений, выполняемых некоторыми операторами с одинаковым приоритетом, помещенными рядом в одном выражении.

Большинство операторов Python имеют левостороннюю ассоциативность, что означает, что вычисление выражения выполняется слева направо.

Этот простой пример покажет вам, как это работает:

```python
print(9 % 6 % 2)
```  

Есть два возможных способа решения этого выражения:

* слева направо: сначала `9%6` равно `3`, и затем `3%2` равно `1`;
* справа налево: сначала `6%2` равно `0`, и затем `9%0` вызывает **фатальную ошибку**.

Запустите пример и посмотрите что получится.

Результат должен быть `1`. Этот оператор имеет **левую ассоциативность**. Но есть одно интересное исключение.


## Операторы и их порядок действий: возведение в степень

Повторите эксперимент, но теперь с возведением в степень.

Используйте этот фрагмент кода:

```python
print(2 ** 2 ** 3)
```  

Два возможных результата:

* `2 ** 2` → `4`; `4 ** 3` → `64`
* `2 ** 3` → `8`; `2 ** 8` → `256`

Запустите код. Что вы видите?

Результат ясно показывает, что **оператор возведения в степень использует правую ассоциативность**.


## Список приоритетов

Поскольку вы новичок в операторах Python, мы не хотим сейчас представлять полный список приоритетов операторов.

Вместо этого мы покажем вам укороченный список и будем последовательно расширять его по мере появления новых операторов.

Посмотрите на таблицу ниже:

| Приоритет | Оператор      |          |
|-----------|---------------|----------|
| 1         | `+`, `-`      | унарный  |
| 2         | `**`          |          |
| 3         | `*`, `/`, `%` |          |
| 4         | `+`, `-`      | бинарный |


**Примечание**. Мы перечислили операторы в порядке **от самого высокого (1) до самого низкого (4) приоритета**.

Попробуйте ввести следующее выражение:

```python
print(2 * 3 % 5)
```  

Оба оператора (`*` и `%`) имеют одинаковый приоритет, поэтому результат можно угадать только тогда, когда вы знаете направление ассоциативности. Как вы думаете, какой будет результат?

<details><summary>Проверка</summary>

`1`

</details>


## Операторы и скобки

Конечно, вам всегда разрешено использовать **круглые скобки**, которые могут изменить естественный порядок вычислений.

В соответствии с арифметическими правилами, **подвыражения в скобках всегда вычисляются первыми**.

Вы можете использовать столько скобок, сколько вам нужно, и они часто используются для **улучшения читаемости** выражения, даже если они не меняют порядок операций.

Посмотрите на пример выражения с несколькими круглыми скобками:

```python
print((5 * ((25 % 13) + 100) / (2 * 13)) // 2)
```  

Попробуйте вычислить значение, которое выводится на консоль. Каков результат функции `print()`?

<details><summary>Проверка</summary>

`10.0`

</details>


## Основные тезисы

1. **Выражение** - это комбинация значений (или переменных, операторов, вызовов функций, о которых вы скоро узнаете), которая возвращает значение, например, `1 + 2`.

2. **Операторы** - это специальные символы или ключевые слова, которые могут работать со значениями и выполнять (математические) операции, например, оператор `*` умножает два значения: `x * y`.

3. Арифметические операторы в Python: `+` (сложение), `-` (вычитание), `*` (умножение), `/` (классическое деление - возвращает число с плавающей запятой, если одно из значений имеет тип с плавающей запятой), `%` (остаток - делит левый операнд на правый операнд и возвращает остаток от операции, например, `5 % 2 = 1`), `**` (возведение в степень - левый операнд возводится в степень правого операнда, например, `2 ** 3 = 2 * 2 * 2 = 8`), `//` (целочисленное деление - возвращает число, полученное в результате деления, но округленное до ближайшего целого числа, например, `3 // 2.0 = 1.0`)

4. **Унарный** это оператор с одним операндом, например, `-1` или `+3`.

5. **Бинарный (двоичный)** - это оператор с двумя операндами, например `4 + 5`, или `12 % 5`.

6. Некоторые операторы действуют раньше других благодаря **иерархии приоритетов**:

   * унарные `+` и `-` имеют самый высокий приоритет;
   * затем: `**`, потом: `*`, `/`, и `%`, а затем самый низкий приоритет: двоичные `+` и `-`.

7. Выражения в **скобках** всегда вычисляются первыми, например, `15 - 1 * (5 * (1 + 2)) = 0`.

8. Оператор **возведение в степень** использует **правую ассоциацию**, например, `2 ** 2 ** 3 = 256`.

**Упражнение 1**

Какой результат у следующего фрагмента?

```python
print((2 ** 4), (2 * 4.), (2 * 4))
```  

<details><summary>Проверка</summary>

`16 8.0 8`

</details>


**Упражнение 2**

Каков результат у следующего фрагмента?

```python
print((-2 / 4), (2 / 4), (2 // 4), (-2 // 4))
```
  
<details><summary>Проверка</summary>

`-0.5 0.5 0 -1`

</details>


**Упражнение 3**

Каков результат у следующего фрагмента?

```python
print((2 % -4), (2 % 4), (2 ** 3 ** 2))
```  

<details><summary>Проверка</summary>

`-2 2 512`

</details>

