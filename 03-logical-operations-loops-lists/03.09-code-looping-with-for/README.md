## Зацикливание кода с помощью `for`

Другой вид цикла, доступный в Python, основан на наблюдении, что иногда важнее **подсчитать "обороты" цикла**, чем
проверять условия.

Представьте, что тело цикла нужно выполнить ровно сто раз. Если вы хотите использовать для этого цикл `while`, он может
выглядеть следующим образом:

```python
i = 0
while i < 100:
    # do_something()
    i += 1

```  

Было бы здорово, если бы кто-нибудь мог сделать за вас этот скучный подсчет. Это возможно?

Конечно, для такого рода задач существует специальный цикл, который называется `for`.

На самом деле цикл `for` предназначен для выполнения более сложных задач - **он может "просматривать" большие коллекции
данных, элемент за элементом**. Мы скоро покажем вам, как это сделать, а сейчас представим более простой вариант его
применения.

Взгляните на фрагмент:

```python
[!mark!]for [! / mark!] i in range(100):
    # do_something()
    pass
```

Есть несколько новых элементов. Расскажем о них:

* ключевое слово _for_ открывает цикл `for`;

  примечание - после него нет условия; вам не нужно думать об условиях, поскольку они проверяются изнутри, без
  какого-либо вмешательства;

* любая переменная после ключевого слова _for_ является **управляющей переменной** цикла; он считает итерации цикла и
  делает это автоматически;
* ключевое слово _in_ вводит элемент синтаксиса, описывающий диапазон возможных значений, присваиваемых управляющей
  переменной;
* функция `range()` (это особая функция) отвечает за генерацию всех желаемых значений управляющей переменной; в нашем
  примере функция будет создавать (мы даже можем сказать, что она будет **кормить** цикл) последующими значениями из
  следующего набора: 0, 1, 2 .. 97, 98, 99; примечание: в этом случае функция `range()` начинает свою работу с 0 и
  заканчивает ее за один шаг (одно целое число) до значения своего аргумента;
* обратите внимание на ключевое слово _pass_ внутри тела цикла - оно вообще ничего не делает; это **пустая инструкция**
  - мы поместили ее сюда, потому что синтаксис цикла `for` требует как минимум одной инструкции внутри тела (кстати
  - `if`, `elif`, `else` и `while` выражают одно и то же).

Наши следующие примеры будут немного скромнее по количеству повторений цикла.

Взгляните на приведенный ниже фрагмент кода. Можете ли вы предсказать его вывод?

```python
for i in range(10):
    print("The value of i is currently", i)

```

Запустите код, чтобы проверить, были ли вы правы.

Примечание:

* цикл был выполнен десять раз (это аргумент функции `range()`)
* значение последней управляющей переменной - `9` (не `10`, так как **оно начинается с `0`**, а не с `1`)

Вызов функции `range()` может иметь два аргумента, а не только один:

```python
for i in range([!mark!]2, 8[! / mark!]):
    print("The value of i is currently", i)

```

В этом случае первый аргумент определяет начальное (первое) значение управляющей переменной.

Последний аргумент показывает первое значение, которое не будет присвоено управляющей переменной.

Примечание: функция `range()` **принимает только целые числа в качестве аргументов** и генерирует последовательности
целых чисел.

Вы можете угадать результат работы программы? Запустите ее, чтобы проверить, были ли вы сейчас правы.

Первое показанное значение - `2` (взято из первого аргумента `range()`).

Последний - `7` (хотя второй аргумент `range()` - `8`).

## Подробнее о цикле `for` и функции `range()` с тремя аргументами

Функция `range()` также может принимать **три аргумента** - взгляните на код.

```python
for i in range(2, 8, 3):
    print("The value of i is currently", i)

```

Третий аргумент - **приращение** - это значение, добавляемое для управления переменной при каждом повороте цикла (как вы
можете подозревать, **значение приращения по умолчанию равно 1**).

Вы можете сказать нам, сколько строк появится в консоли и какие значения они будут содержать?

Запустите программу, чтобы узнать, правы ли вы.

В окне консоли вы должны увидеть следующие строки:

```
The value of i is currently 2
The value of i is currently 5
```

Знаете почему? Первый аргумент, переданный функции `range()`, сообщает нам, какой **начальный** номер
последовательности (отсюда `2` в выводе). Второй аргумент сообщает функции, где **остановить** последовательность (
функция генерирует числа до числа, указанного вторым аргументом, но не включает его). Наконец, третий аргумент
указывает **шаг**, который фактически означает разницу между каждым числом в последовательности чисел, созданной
функцией.

`2` (начальное число) → `5` (`2` увеличить на 3 равно `5` - число находится в диапазоне от 2 до 8) → `8` (`5` увеличить
на 3 равно `8` - число не находится в диапазоне от 2 до 8, поскольку параметр остановки не включен в последовательность
чисел, сгенерированная функцией).

Примечание: если набор, сгенерированный функцией `range()`, пуст, цикл вообще не выполнит свое тело.

Как и здесь - вывода не будет:

```python
for i in range(1, 1):
    print("The value of i is currently", i)

```

Примечание: набор, созданный с помощью `range()`, должен быть отсортирован в **порядке возрастания**. Невозможно
заставить `range()` создать набор в другой форме, если функция `range()` принимает ровно два аргумента. Это означает,
что второй аргумент `range()` должен быть больше первого.

Таким образом, здесь тоже не будет вывода:

```python
for i in range(2, 1):
    print("The value of i is currently", i)

```

Давайте посмотрим на небольшую программу, задача которой - написать некоторые из первых степеней двойки:

```python
power = 1
for expo in range(16):
    print("2 to the power of", expo, "is", power)
    power *= 2

```

Переменная `expo` используется как управляющая переменная для цикла и указывает текущее значение _экспоненты_. Само
возведение в степень заменяется умножением на два. Поскольку 2<sup>0</sup> равно 1, то 2 × 1 равно 2<sup>1</sup>, 2 ×
2<sup>1</sup> равно 2<sup>2</sup> и так далее. Для какого наибольшего показателя наша программа все еще выводит
результат?

Запустите код и проверьте, соответствует ли вывод Вашим ожиданиям.

  
