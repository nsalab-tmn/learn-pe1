## Компьютерная логика

Вы заметили, что условия, которые мы использовали до сих пор, были очень простыми, если не сказать, довольно примитивными? Условия, которые мы используем в реальной жизни, намного сложнее. Давайте посмотрим на это предложение:

_Если у нас будет немного свободного времени, и погода будет хорошей, мы пойдем гулять._

Мы использовали союз `и` , что означает, что прогулка зависит от одновременного выполнения этих двух условий. На языке логики такое соединение условий называется **конъюнкцией**. А теперь еще один пример:

_Если ты находишься в торговом центре или если я нахожусь в торговом центре, то один из нас купит подарок для мамы._

Появление слова `или` означает, что покупка зависит хотя бы от одного из этих условий. В логике такое соединение называется **дизъюнкцией**.

Понятно, что в Python должны быть операторы для построения конъюнкций и дизъюнкций. Без них выразительная сила языка была бы существенно ослаблена. Они называются **логическими операторами**.

### `and`

Одним из операторов логического соединения в Python является слово _and_. Это **бинарный оператор с более низким приоритетом, чем тот, который имеют операторы сравнения**. Это позволяет нам кодировать сложные условия без использования круглых скобок, подобные этому:

`counter > 0 [!mark!]and[!/mark!] value == 100`  

Результат, получаемый при использовании оператора `and`, может быть определен на основе **таблицы истинности**.

Если мы рассмотрим конъюнкцию `A [!mark!]and[!/mark!] B`, набор возможных значений аргументов и соответствующих значений конъюнкции выглядит следующим образом:

| Аргумент `A` | Аргумент `B` | `A [!mark!]and[!/mark!] B` |
|--------------|--------------|----------------------------|
| `False`      | `False`      | `False`                    |
| `False`      | `True`       | `False`                    |
| `True`       | `False`      | `False`                    |
| `True`       | `True`       | `True`                     |


### `or`

Оператор дизъюнкции - это слово `or`. Это **бинарный оператор с более низким приоритетом, чем у `and`** (точно так же, как `+` по сравнению с `*`). Его таблица истинности выглядит следующим образом:

| Аргумент `A` | Аргумент `B` | `A [!mark!]or[!/mark!] B` |
|--------------|--------------|---------------------------|
| `False`      | `False`      | `False`                   |
| `False`      | `True`       | `True`                   |
| `True`       | `False`      | `True`                   |
| `True`       | `True`       | `True`                    |
  

### `not`

Кроме того, есть еще один оператор, который можно применять для построения условий. Это **унарный оператор, выполняющий логическое отрицание**. Его действие простое: он превращает истину в ложь, а ложь - в истину.

Этот оператор записывается как слово `not`, и его **приоритет очень высок: такой же, как у унарных `+` и `-`**. Его таблица истинности проста:

| Аргумент | `[!mark!]not[!/mark!]` Аргумент |
|----------|---------------------------------|
| `False`  | `True`                          |
| `True`   | `False`                         |
  

## Логические выражения

Давайте создадим переменную с именем `var` и присвоим ей `1`. Следующие условия **попарно эквивалентны**:

```
# Пример 1:
print([!mark!]var > 0[!/mark!])
print([!mark!]not (var <= 0)[!/mark!])


# Пример 2:
print([!mark!]var != 0[!/mark!])
print([!mark!]not (var == 0)[!/mark!])

```

Возможно, вы знакомы с законами Де Моргана. Они говорят, что:

_Отрицание конъюнкции - это дизъюнкция отрицаний._

_Отрицание дизъюнкции - это конъюнкция отрицаний._

Напишем то же самое на Python:

```python
not (p and q) == (not p) or (not q)
not (p or q) == (not p) and (not q)
```

Обратите внимание, как круглые скобки использовались для кодирования выражений - мы поместили их туда, чтобы улучшить читаемость.

Следует добавить, что ни один из этих операторов с двумя аргументами нельзя использовать в сокращенной форме, известной как `op=`. Об этом исключении стоит помнить.

### Логические значения и отдельные биты

Логические операторы принимают аргументы как единое целое независимо от того, сколько битов они содержат. Операторам известно только значение: ноль (когда все биты сброшены) означает `False`; ненулевое значение (если установлен хотя бы один бит) означает `True`.

Результатом их операций является одно из следующих значений: `False` или `True`. Это означает, что этот фрагмент кода присвоит значение `True` переменной `j`, если `i` не равно нулю; в противном случае будет `False`.

```python
i = 1
j = not not i
```  

## Побитовые операторы

Однако есть четыре оператора, которые позволяют **манипулировать отдельными битами данных**. Они называются **побитовыми операторами**.

Они охватывают все упомянутые ранее операции в логическом контексте и один дополнительный оператор. Это оператор `xor` (как в **исключающем или**), он обозначается как `^`(карет).

Вот они все:

* `&` (амперсанд) ‒ побитоваая конъюнкция;
* `|` (вертикальная черта) ‒ побитоваая дизъюнкция;
* `~` (тильда) ‒ побитовое отрицание;
* `^` (карет) ‒ побитовое исключающее или (xor).
 

**Побитовые операции (`&`, `|`, и `^`)**

| Аргумент `A` | Аргумент `B` | `A & B` | `A \| B` | `A ^ B` |
|--------------|--------------|---------|----------|---------|
| `0`          | `0`          | `0`     | `0`      | `0`     |
| `0`          | `1`          | `0`     | `1`      | `1`     |
| `1`          | `0`          | `0`     | `1`      | `1`     |
| `1`          | `1`          | `1`     | `1`      | `0`     |

**Побитовые операции (`~`)**

| Аргумент | `~` Аргумент |
|----------|--------------|
| `0`      | `1`          |
| `1`      | `0`          |

Давайте сделаем проще:

* `&` требует ровно два бита `1` для предоставления в качестве результата `1`;
* `|` требует хотя бы одного бита `1` для предоставления `1` в качестве результата;
* `^` требует ровно одного бита `1` для предоставления `1` в качестве результата.

Добавим важное замечание: аргументы этих операторов **должны быть целыми числами**; мы не должны использовать здесь числа с плавающей запятой.

Важна разница в работе логических и битовых операторов: **логические операторы не проникают на битовый уровень своего аргумента**. Их интересует только конечное целочисленное значение.

Побитовые операторы более строгие: они обрабатывают **каждый бит отдельно**. Если мы предположим, что целочисленная переменная занимает 64 бита (что является обычным явлением в современных компьютерных системах), вы можете представить поразрядную операцию как 64-кратную оценку логического оператора для каждой пары битов аргументов. Эта аналогия явно несовершенная, поскольку в реальном мире все эти 64 операции выполняются в одно и то же время (одновременно).

Теперь мы покажем вам пример разницы в работе логических и битовых операций. Предположим, что были выполнены следующие задания:

```python
i = 15
j = 22  
```

Если мы предположим, что целые числа хранятся на 32 битах, побитовое изображение двух переменных будет следующим:

```
i: 00000000000000000000000000001111
j: 00000000000000000000000000010110
```  

Дано задание:

```python
log = i and j
```  

Здесь мы имеем дело с логической конъюнкцией. Проследим ход расчетов. Обе переменные `i` и `j` не являются нулями, поэтому будут считаться представляющими `True`. Просматривая таблицу истинности для оператора `and`, мы видим, что результатом будет `True`. Никаких других операций не производится.

```
log: True
```  

Теперь побитовая операция - вот она:

```python
bit = i & j
```  

Оператор `&` будет работать с каждой парой соответствующих битов отдельно, считая значения соответствующих битов результата. Следовательно, результат будет таким:

| `i`           | `000000000000000000000000000[!mark!]01111[!/mark!]` |
|---------------|-----------------------------------------------------|
| `j`           | `000000000000000000000000000[!mark!]10110[!/mark!]` |
| `bit = i & j` | `000000000000000000000000000[!mark!]00110[!/mark!]` |

Эти биты соответствуют целочисленному значению шести.

Теперь посмотрим на операторы отрицания. Сначала логический:

```python
logneg = not i
```  

Значение переменной `logneg` будет установлено на `False` - больше ничего делать не нужно.

Побитовое отрицание выглядит так:

```python
bitneg = ~i
```  

Это может быть немного удивительно: значение переменной `bitneg` равно `-16`. Это может показаться странным, но это совсем не так. Если вы хотите узнать больше, Вам следует изучить двоичную систему счисления и правила, регулирующие числа с дополнением до двух.

| `i`           | `0000000000000000000000000000[!mark!]1111[!/mark!]` |
|---------------|-----------------------------------------------------|
| `bitneg = ~i` | `1111111111111111111111111111[!mark!]0000[!/mark!]` |

Каждый из этих операторов с двумя аргументами можно использовать в **сокращенной форме**. Вот примеры их эквивалентных обозначений:

| `x = x & y`  | `x [!mark!]&=[!/mark!] y`   |
|--------------|------------|
| `x = x \| y` | `x [!mark!]\|=[!/mark!] y` |
| `x = x ^ y`  | `x [!mark!]^=[!/mark!] y`   |


## Что делать с одиночными битами?

Теперь мы покажем вам, для чего можно использовать побитовые операторы. Представьте, что вы разработчик, которому необходимо написать важную часть операционной системы. Вам сказали, что вам разрешено использовать переменную, назначенную следующим образом:

```python
flag_register = 0x1234
```  

В переменной хранится информация о различных аспектах работы системы. **Каждый бит переменной хранит одно значение да/нет**. Вам также сказали, что только один из этих битов принадлежит Вам - третий (помните, что биты нумеруются с нуля, нулевой бит - самый младший, а самый старший - номер 31). Остальные биты не могут быть изменены, потому что они предназначены для хранения других данных. Вот Ваш бит, отмеченный буквой `x`:

```python
flag_register = 0000000000000000000000000000[!mark!]x[!/mark!]000
```  

Вы можете столкнуться со следующими задачами:

1. **Проверьте состояние своего бита** - Вы хотите узнать его значение; сравнение всей переменной с нулем ничего не даст, потому что оставшиеся биты могут иметь совершенно непредсказуемые значения, но вы можете использовать следующее свойство конъюнкции:

    ```python
    x & 1 = x
    x & 0 = 0
    ```

    Если вы примените операцию `&` к переменной `flag_register` в соответствии со следующим битовым изображением:

    ```python
    0000000000000000000000000000[!mark!]1[!/mark!]000
    ```  

    (обратите внимание на `1` в позиции вашего бита) в результате вы получите одну из следующих битовых строк:

   * `0000000000000000000000000000[!mark!]1[!/mark!]000` если ваш бит был установлен на `1`
   * `0000000000000000000000000000[!mark!]0[!/mark!]000` если ваш бит был сброшен на `0`

    Такая последовательность нулей и единиц, задача которой - захватить значение или изменить выбранные биты, называется **битовой маской**.

    Давайте создадим битовую маску для определения состояния вашего бита. Он должен указывать на **третий бит**. Этот бит имеет позиционный вес 2<sup>3</sup> = 8. Подходящую маску можно создать с помощью следующей декларации:

    ```python
    the_mask = 8  
    ```

    Вы также можете составить последовательность инструкций в зависимости от состояния вашего бита:

    ```python
    if flag_register & the_mask:
        # My bit is set.
    else:
        # My bit is reset.
    
    ```

2. **Сбросьте свой бит** - вы присваиваете биту ноль, в то время как все остальные биты должны оставаться неизменными; давайте использовать то же свойство конъюнкции, что и раньше, но давайте использовать немного другую маску - точно так, как показано ниже:

   ```
   11111111111111111111111111110111[!mark!]0[!/mark!]111
   ```  
   
   Обратите внимание, что маска была создана в результате отрицания всех битов переменной `the_mask`. Сброс бита прост и выглядит так (выберите тот, который вам больше нравится):
   
   ```python
   flag_register = flag_register & ~the_mask
   flag_register &= ~the_mask
   ```

3. **Установите свой бит** - вы присваиваете своему биту `1`, в то время как все остальные биты должны оставаться неизменными; используйте следующее свойство дизъюнкции:

   ```
   x | 1 = 1
   x | 0 = x
   ```
   
   Теперь вы готовы внести свой вклад, выполнив одну из следующих инструкций:
   
   ```python
   flag_register = flag_register | the_mask
   flag_register |= the_mask
   ```

4. **Инвертируйте свой бит** - вы заменяете `1` на `0` и `0` на `1`. Вы можете использовать интересное свойство оператора `xor`:

   ```
   x ^ 1 = ~x
   x ^ 0 = x
   ``` 
   
   и инвертировать свой бит с помощью следующих инструкций:
   
   ```python
   flag_register = flag_register ^ the_mask
   flag_register ^= the_mask
   ```  


## Бинарный сдвиг влево и бинарный сдвиг вправо

Python предлагает еще одну операцию, связанную с отдельными битами: **сдвиг**. Это применяется только к **целым** значениям, и Вы не должны использовать для него числа с плавающей запятой в качестве аргумента.

Вы уже применяете эту операцию очень часто и совершенно бессознательно. Как умножить любое число на десять? Посмотрите:

```
12345 × 10 = 123450
```

Как видите, **умножение на десять - это фактически сдвиг** всех цифр влево и заполнение полученного пробела нулем.

Деление на десять? Посмотрите:

```
12340 ÷ 10 = 1234
```

Деление на десять - это не что иное, как сдвиг цифр вправо.

Компьютер выполняет такую же операцию, но с одним отличием: поскольку два - это основание для двоичных чисел (не 10), **сдвиг значения на один бит влево, таким образом, соответствует его умножению на два; соответственно, **сдвиг на один бит вправо аналогичен делению на два** (обратите внимание, что самый правый бит теряется).**

**Операторы сдвига** в Python представляют собой пару **диграфов**: `<<` и `>>`, ясно говорящих, в каком направлении будет произведен сдвиг.

```
value << bits
value >> bits  
```

**Левый аргумент этих операторов - целое число, биты которого сдвинуты. Правый аргумент определяет размер сдвига.**

Это показывает, что эта операция, конечно, не коммутативна.

Приоритет этих операторов очень высок. Вы увидите их в обновленной таблице приоритетов, которую мы покажем вам в конце этого раздела.


Посмотрите на сдвиги.

```python
var = 17
var_right = var >> 1
var_left = var << 2
print(var, var_left, var_right)

```

Последний вызов `print()` дает следующий результат:

```
17 68 8
```

Примечание:

* `17 >> 1` → `17 // 2` (**17**, разделенное на **2 в степени 1**) → `8` (сдвиг вправо на один бит аналогичен целочисленному делению на два)
* `17 << 2` → `17 * 4` (**17**, умноженное на **2 в степени 2**) → `68` (сдвиг влево на два бита аналогичен целочисленному умножению на четыре)

А вот и **обновленная таблица приоритетов**, содержащая все введенные операторы:

| Priority | Operator                                                           |        |
|----------|--------------------------------------------------------------------|--------|
| 1        | `~`, `+`, `-`                                                      | unary  |
| 2        | `**`                                                               |        |
| 3        | `*`, `/`, `//`, `%`                                                |        |
| 4        | `+`, `-`                                                           | binary |
| 5        | `<<`, `>>`                                                         |        |
| 6        | `<`, `<=`, `>`, `>=`                                               |        |
| 7        | `==`, `!=`                                                         |        |
| 8        | `&`                                                                |        |
| 9        | `\|`                                                               |        |
| 10       | `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `^=`, `\|=`, `>>=`, `<<=` |        |


## Основные тезисы

1. Python поддерживает следующие логические операторы:

   * `and` → если оба операнда верны, условие истинно, например, `(True and True)` равно `True`,
   * `or` → если какой-либо из операндов истинен, условие истинно, например, `(True or False)` равно `True`,
   * `not` → возвращает false, если результат истинный, и возвращает true, если результат ложный, например, `not True` равно `False`.

2. Вы можете использовать побитовые операторы для манипуляции отдельными битами данных. Следующий пример данных:

   * `x = 15`, что равняется `0000 1111` в двоичном формате,
   * `y = 16`, что равняется `0001 0000` в двоичном формате.

будет использоваться для иллюстрации значения побитовых операторов в Python. Проанализируйте приведенные ниже примеры:

  * `&`выполняет _побитовое и_, например, `x & y = 0`, что равняется `0000 0000` в двоичном формате,
  * `|`выполняет _побитовое или_, например, `x | y = 31`, что равняется `0001 1111` в двоичном формате ,
  * `˜` выполняет _побитовое не_, например, `˜x = 240`, что равняется `1111 0000` в двоичном формате,
  * `^` выполняет _побитовое исключающее или_, например, `x ^ y = 31`, что равняется `0001 1111` в двоичном формате,
  * `>>` выполняет _побитовый сдвиг вправо_, например, `y >> 1 = 8`, что равняется `0000 1000` в двоичном формате,
  * `<<` выполняет _побитовый сдвиг влево_, например, `y<< 3 = 128`, что равняется `1000 0000` в двоичном формате,
  * `-16` (десятичное от дополнения до двух со знаком) - подробнее об операции [Дополнительный код](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4).

**Упражнение 1**

Что выведет следующий фрагмент кода?

```python
x = 1
y = 0

z = ((x == y) and (x == y)) or not(x == y)
print(not(z))

```  

<details><summary>Проверка</summary>

```
False
```

</details>


**Упражнение 2**

Что выведет следующий фрагмент кода?

```python
x = 4
y = 1

a = x & y
b = x | y
c = ~x  # tricky!
d = x ^ 5
e = x >> 2
f = x << 2

print(a, b, c, d, e, f)

```  

<details><summary>Проверка</summary>

```
0 5 -5 1 1 16
```

</details>

