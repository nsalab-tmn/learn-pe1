## Внутренняя жизнь списков

Теперь мы хотим показать вам одну важную и очень удивительную особенность списков, которая сильно отличает их от обычных переменных.

Мы хотим, чтобы вы запомнили ее - она может повлиять на Ваши будущие программы и вызвать серьезные проблемы, если будет забыта или упущена из виду.

Взгляните на фрагмент кода.

```python
list_1 = [1]
list_2 = list_1
list_1[0] = 2
print(list_2)

```

Программа:

* создает одноэлементный список с именем `list_1`;
* присваивает его новому списку с именем `list_2`;
* изменяет единственный элемент `list_1`;
* выводит `list_2`.

Удивительно то, что программа выведет: `[2]`, а не `[1]`, что кажется очевидным решением.

Списки (и многие другие сложные объекты Python) хранятся иначе, чем обычные (скалярные) переменные.

Вы можете сказать, что:

* имя обычной переменной - это **имя ее содержимого**;
* имя списка - это имя **области памяти, в которой хранится список**.

Прочтите эти две строки еще раз - разница важна для понимания того, о чем мы будем говорить дальше.

Присваивание: `list_2 = list_1` копирует имя массива, а не его содержимое. Фактически, два имени (`list_1` и `list_2`) идентифицируют одно и то же место в памяти компьютера. Изменение одного из списков влияет на другой, и наоборот.

Что с этим делать?


## Могучие срезы

К счастью, решение всегда у вас под рукой - оно называется **срез**.

Срез - это элемент синтаксиса Python, который позволяет Вам **создавать новую копию списка или его частей**.

Фактически он копирует содержимое списка, а не его имя.

Это именно то, что вам нужно. Взгляните на приведенный ниже фрагмент кода:

```
list_1 = [1]
list_2 = list_1[!mark!][:][!/mark!]
list_1[0] = 2
print(list_2)

```  

Он выведет `[1]`.

Эта незаметная часть кода, описанная как `[:]`, может создавать совершенно новый список.

Одна из наиболее общих форм среза выглядит следующим образом:

```python
my_list[start:end]
```  

Как видите, это похоже на индексацию, но двоеточие внутри имеет большое значение.

Срез этой формы **создает новый (целевой) список, беря элементы из исходного списка - элементы с индексами от начала до `end - 1`**.

Примечание: не до `end`, а до `end - 1`. Элемент с индексом, равным `end`, является первым элементом, **не участвующим в нарезке**.

Возможно использование отрицательных значений как для начала, так и для конца (как при индексации).

Посмотрите на фрагмент кода:

```
my_list = [10, 8, 6, 4, 2]
new_list = my_list[!mark!][1:3][!/mark!]
print(new_list)
```  

В списке `new_list` будет `end - start` (3 - 1 = 2) элементов - с индексами, равными `1` и `2` (но не `3`).

Вывод кода: `[8, 6]`

## Срезы ‒ отрицательные индексы

Посмотрите на код ниже:

```python
my_list[start:end]
```  

Повторение:

* `start` - это индекс первого элемента, **включенного в срез**;
* `end` - это индекс первого элемента, **не включенного в срез.**

Вот как **отрицательные индексы** работают со срезом:

```
my_list = [10, 8, 6, 4, 2]
new_list = my_list[!mark!][1:-1][!/mark!]
print(new_list)
```  

Программа выведет:

`[8, 6, 4]`

Если `start` указывает на элемент, располагающийся дальше, чем тот, на который указывает `end` (от начала списка), срез будет **пустым**:

```
my_list = [10, 8, 6, 4, 2]
new_list = my_list[!mark!][-1:1][!/mark!]
print(new_list)
```  

Программа выведет:

`[]`

Если вы опустите `start` в своем фрагменте, предполагается, что вы хотите получить фрагмент, начинающийся с элемента с индексом `0`.

Другими словами, срез этой формы:

```python
my_list[:end]
```  

является более компактным эквивалентом этой:

```python
my_list[0:end]
```  

Посмотрите на код ниже:

```
my_list = [10, 8, 6, 4, 2]
new_list = my_list[!mark!][:3][!/mark!]
print(new_list)
``` 

Вот почему его вывод: `[10, 8, 6]`.

Точно так же, если вы опускаете `end` в своем фрагменте, предполагается, что вы хотите, чтобы фрагмент заканчивался на элементе с индексом `len(my_list)`.

Другими словами, срез этой формы:

```python
my_list[start:]
```  

является более компактным эквивалентом этой:

```python
my_list[start:len(my_list)]
```  

Посмотрите на следующий код:

```
my_list = [10, 8, 6, 4, 2]
new_list = my_list[!mark!][3:][!/mark!]
print(new_list)
```  

Таким образом, его вывод: `[4, 2]`.

Как мы уже говорили ранее, если опустить и `start`, и `end`, создается **копия всего списка**:

```
my_list = [10, 8, 6, 4, 2]
new_list = my_list[!mark!][:][!/mark!]
print(new_list)
```  

Вывод программы: `[10, 8, 6, 4, 2]`.

Описанная ранее инструкция `del` может **удалять за один раз не только элементы списка - она также может удалять срезы**:

```
my_list = [10, 8, 6, 4, 2]
[!mark!]del my_list[1:3][!/mark!]
print(my_list)
```  

Примечание: в этом случае срез **не создает новый список**!

Вывод программы: `[10, 4, 2]`.

Также возможно удаление **всех элементов** сразу:

```
my_list = [10, 8, 6, 4, 2]
[!mark!]del my_list[:][!/mark!]
print(my_list)
```  

Список становится пустым, и вывод будет: `[]`.

Удаление фрагмента из кода кардинально меняет его значение.

Взгляните:

```
my_list = [10, 8, 6, 4, 2]
[!mark!]del my_list[!/mark!]
print(my_list)
```  

Инструкция `del` **удалит только список, не его содержимое**.

Вызов функции `print()` в последней строке кода вызовет ошибку времени выполнения.

  
## Операторы `in` и `not in`

Python предлагает два очень мощных оператора, которые могут **просматривать список, чтобы проверить, хранится ли в нем конкретное значение**.

Вот эти операторы:

```
elem [!mark!]in[!/mark!] my_list
elem [!mark!]not in[!/mark!] my_list
```

Первый (`in`) проверяет, хранится ли данный элемент (левый аргумент) в настоящее время где-то внутри списка (правый аргумент) - в этом случае оператор возвращает `True`.

Второй (`not in`) проверяет, отсутствует ли данный элемент (левый аргумент) в списке - в этом случае оператор возвращает `True`.

Посмотрите на код. В нем показаны оба оператора в действии. Вы можете угадать, что он выведет? Запустите программу, чтобы проверить, были ли Вы правы.

```python
my_list = [0, 3, 12, 8, 2]

print(5 in my_list)
print(5 not in my_list)
print(12 in my_list)

```


## Списки - несколько простых программ

Теперь мы хотим показать вам несколько простых программ, использующих списки.

Первая из них пытается найти в списке наибольшее значение. Посмотрите на код.

```python
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in range(1, len(my_list)):
    if my_list[i] > largest:
        largest = my_list[i]

print(largest)

```

Идея довольно проста - мы предполагаем, что первый элемент является наибольшим, и проверяем гипотезу для всех остальных элементов в списке.

Код выводит `17` (как и ожидалось).

Код может быть переписан, чтобы использовать новую форму цикла `for`:

```python
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in my_list:
    if i > largest:
        largest = i

print(largest)

```  

Приведенная выше программа выполняет одно ненужное сравнение, когда первый элемент сравнивается сам с собой, но это вовсе не проблема.

Этот код также выводит `17` (ничего необычного).

Если вам нужно сэкономить мощность компьютера, вы можете использовать срез:

```python
my_list = [17, 3, 11, 5, 1, 9, 7, 15, 13]
largest = my_list[0]

for i in my_list[1:]:
    if i > largest:
        largest = i

print(largest)

```  

Возникает вопрос: какое из этих двух действий потребляет больше ресурсов компьютера - всего одно сравнение или срезание почти всех элементов списка?

Теперь давайте найдем расположение данного элемента внутри списка:

```python
my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
to_find = 5
found = False

for i in range(len(my_list)):
    found = my_list[i] == to_find
    if found:
        break

if found:
    print("Element found at index", i)
else:
    print("absent")

```  

Примечание:

* целевое значение сохраняется в переменной `to_find`;
* текущий статус поиска сохраняется в переменной `found` (`True`/`False`)
* когда `found` становится `True`, цикл `for` завершается.

Предположим, что вы выбрали следующие номера в лотерее: `3`, `7`, `11`, `42`, `34`, `49`.

Выпали следующие числа: `5`, `11`, `9`, `42`, `3`, `49`.

Вопрос: сколько чисел Вы угадали?

Эта программа даст Вам ответ:

```python
drawn = [5, 11, 9, 42, 3, 49]
bets = [3, 7, 11, 42, 34, 49]
hits = 0

for number in bets:
    if number in drawn:
        hits += 1

print(hits)

```  

Примечание:

* список `drawn` хранит все выпавшие числа;
* в списке `bets` хранятся ваши ставки;
* переменная `hits` подсчитывает количество Ваших попаданий.

Вывод программы: `4`.

  
## Основные тезисы

1. Если у вас есть список `list_1`, то следующее присваивание: `list_2 = list_1` не создает копию списка `list_1`, оно делает так, что переменные `list_1` и `list_2` **указывают на один и тот же список в памяти**. Например:

    ```python
    vehicles_one = ['car', 'bicycle', 'motor']
    print(vehicles_one) # outputs: ['car', 'bicycle', 'motor']
    
    vehicles_two = vehicles_one
    del vehicles_one[0] # deletes 'car'
    print(vehicles_two) # outputs: ['bicycle', 'motor']
    
    ```

2. Если вы хотите скопировать список или его часть, вы можете сделать это, используя **срез**:

    ```python
    colors = ['red', 'green', 'orange']
    
    copy_whole_colors = colors[:]  # copy the entire list
    copy_part_colors = colors[0:2]  # copy part of the list
    
    ```

3. Вы также можете использовать **отрицательные индексы** для выполнения срезов. Например:

    ```python
    sample_list = ["A", "B", "C", "D", "E"]
    new_list = sample_list[2:-1]
    print(new_list)  # outputs: ['C', 'D']
    
    ```
  
4. Параметры `start` и `end` являются **необязательными** при выполнении среза: `list[start:end]`, например:

    ```python
    my_list = [1, 2, 3, 4, 5]
    slice_one = my_list[2: ]
    slice_two = my_list[ :2]
    slice_three = my_list[-2: ]
    
    print(slice_one)  # outputs: [3, 4, 5]
    print(slice_two)  # outputs: [1, 2]
    print(slice_three)  # outputs: [4, 5]
    
    ```  

5. Вы можете **удалить фрагменты** с помощью инструкции `del`:

    ```python
    my_list = [1, 2, 3, 4, 5]
    del my_list[0:2]
    print(my_list)  # outputs: [3, 4, 5]
    
    del my_list[:]
    print(my_list)  # deletes the list content, outputs: []
    
    ```  

6. Вы можете проверить, **существуют ли какие-либо элементы в списке или нет**, используя ключевые слова `in` и `not in`, например:

    ```python
    my_list = ["A", "B", 1, 2]
    
    print("A" in my_list)  # outputs: True
    print("C" not in my_list)  # outputs: True
    print(2 not in my_list)  # outputs: False
    
    ```  
  

**Упражнение 1**

Что выведет следующий код?

```python
list_1 = ["A", "B", "C"]
list_2 = list_1
list_3 = list_2

del list_1[0]
del list_2[0]

print(list_3)

```
  
<details><summary>Проверка</summary>

`['C']`

</details>

**Упражнение 2**

Что выведет следующий код?

```python
list_1 = ["A", "B", "C"]
list_2 = list_1
list_3 = list_2

del list_1[0]
del list_2

print(list_3)

```
  
<details><summary>Проверка</summary>

`['B', 'C']`

</details>

**Упражнение 3**

Что выведет следующий код?

```python
list_1 = ["A", "B", "C"]
list_2 = list_1
list_3 = list_2

del list_1[0]
del list_2[:]

print(list_3)

```
  
<details><summary>Проверка</summary>

`[]`

</details>

**Упражнение 4**

Что выведет следующий код?

```python
list_1 = ["A", "B", "C"]
list_2 = list_1[:]
list_3 = list_2[:]

del list_1[0]
del list_2[0]

print(list_3)

```
  
<details><summary>Проверка</summary>

`['A', 'B', 'C']`

</details>

**Упражнение 5**

Вставьте `in` или `not in` вместо `???`, чтобы код вывел ожидаемый результат.

```python
my_list = [1, 2, "in", True, "ABC"]

print(1 ??? my_list)  # outputs True
print("A" ??? my_list)  # outputs True
print(3 ??? my_list)  # outputs True
print(False ??? my_list)  # outputs False

```
  
<details><summary>Проверка</summary>

```python
my_list = [1, 2, "in", True, "ABC"]

print(1 in my_list)  # outputs True
print("A" not in my_list)  # outputs True
print(3 not in my_list)  # outputs True
print(False in my_list)  # outputs False

```

</details>

