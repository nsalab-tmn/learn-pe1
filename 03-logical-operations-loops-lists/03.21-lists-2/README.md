## Функции и методы

**Метод - это особый вид функции**: он ведет себя как функция и выглядит как функция, но отличается по способу действия и стилю вызова.

**Функция не принадлежит никаким данным** - она получает данные, она может создавать новые данные и (как правило) дает результат.

Все это выполняет и метод, но он также может **изменять состояние выбранной сущности**.

**Метод принадлежит данным, для которых он работает, а функция - всему коду**.

  

Это также означает, что для вызова метода требуется некоторая спецификация данных, из которых вызывается метод.

Это может показаться загадочным, но мы разберемся с этим более подробно, когда углубимся в объектно-ориентированное программирование.

В общем, типичный вызов функции может выглядеть так:

```
result = [!mark!]function(arg)[!/mark!]
```  

Функция принимает аргумент, что-то делает и возвращает результат.

Типичный вызов метода обычно выглядит так:

```
result = [!mark!]data.method(arg)[!/mark!]
```  

Примечание: имени метода предшествует имя данных, которым принадлежит метод. Затем вы добавляете **точку**, после нее **имя метода** и пару **скобок, заключающих аргументы**.

Метод будет вести себя как функция, но может делать кое-что еще - он может **изменять внутреннее состояние данных**, из которых он был вызван.

Вы спросите: почему мы говорим о методах, а не о списках?

Сейчас это важная задача, поскольку мы собираемся показать вам, как добавлять новые элементы в существующий список. Это можно сделать с помощью методов, принадлежащих всем спискам, а не функциям.


## Добавление элементов в список: `append()` и `insert()`

Новый элемент может быть _приклеен_ к концу существующего списка:

```
list[!mark!].append(value)[!/mark!]
```  

Такая операция выполняется методом под названием `append()`. Он берет значение своего аргумента и помещает его **в конец списка**, которому принадлежит метод.

После этого длина списка увеличивается на единицу.

Метод `insert()` немного умнее - он может добавить новый элемент **в любое место в списке**, а не только в конец.

```
list[!mark!].insert(location, value)[!/mark!]
```  

Он принимает два аргумента:

* первый показывает требуемое расположение вставляемого элемента; примечание: все существующие элементы, которые занимают места справа от нового элемента (включая тот, который находится в указанной позиции), смещаются вправо, чтобы освободить место для нового элемента;
* второй - элемент, который нужно вставить.

Взгляните на код. Посмотрите, как мы используем методы `append()` и `insert()`. Обратите внимание на то, что происходит после использования `insert()`: бывший первый элемент теперь является вторым, второй - третьим и так далее.

```python
numbers = [111, 7, 2, 1]
print(len(numbers))
print(numbers)

###

numbers.append(4)

print(len(numbers))
print(numbers)

###

numbers.insert(0, 222)
print(len(numbers))
print(numbers)

#

```

Добавьте следующий фрагмент после последней строки кода в редакторе:

```python
numbers.insert(1, 333)
```  

Распечатайте окончательное содержимое списка на экране и посмотрите, что произойдет. Приведенный выше фрагмент вставляет `333` в список, делая его вторым элементом. Первый второй элемент становится третьим, третий - четвертым и так далее.

Вы можете **начать жизнь списка, сделав его пустым** (это делается с помощью пары пустых квадратных скобок), а затем добавив в него новые элементы по мере необходимости.

Взгляните на фрагмент кода. Попробуйте угадать результат после выполнения цикла `for`. Запустите программу, чтобы проверить, были ли вы правы.

```python
my_list = []  # Creating an empty list.

for i in range(5):
    my_list.append(i + 1)

print(my_list)

```

Это будет последовательность целых чисел от `1` (затем вы добавляете единицу ко всем добавленным значениям) до `5`.

Мы немного изменили фрагмент кода:

```
my_list = []  # Creating an empty list.

for i in range(5):
    my_list[!mark!].insert(0, i + 1)[!/mark!]

print(my_list)


```

Что произойдет? Запустите программу и проверьте, правы ли вы и на этот раз.

Вы должны получить ту же последовательность, но в **обратном порядке** (в этом заслуга использования метода `insert()`).  


## Использование списков

У цикла `for` есть специальный вариант, который может очень эффективно **обрабатывать списки** - давайте посмотрим на это.

Предположим, Вы хотите **вычислить сумму всех значений, хранящихся в списке `my_list`**.

Вам нужна переменная, сумма которой будет сохранена и изначально присвоено значение `0` - ее имя будет `total`. (Примечание: мы не собираемся называть его `sum`, поскольку Python использует то же название для одной из своих встроенных функций: `sum()`. **Использование того же названия обычно считается плохой практикой**.) Затем вы добавляете к нему все элементы списка с помощью цикла `for`. Взгляните на фрагмент кода.

```python
my_list = [10, 1, 8, 3, 5]
total = 0

for i in range(len(my_list)):
    total += my_list[i]

print(total)

```

Прокомментируем этот пример:

* списку присваивается последовательность из пяти целочисленных значений;
* переменная `i` принимает значения `0`, `1`, `2`, `3` и `4`, а затем индексирует список, выбирая следующие элементы: первый, второй, третий, четвертый и пятый;
* каждый из этих элементов добавляется оператором `+=` к переменной `total`, давая окончательный результат в конце цикла;
* обратите внимание на способ использования функции `len()` - она делает код независимым от любых возможных изменений в содержимом списка.


### Второй аспект цикла for

Но цикл `for` может намного больше. Он может скрыть все действия, связанные с индексацией списка, и предоставить удобным способом все элементы списка.

Этот модифицированный фрагмент кода показывает, как это работает:

```python
my_list = [10, 1, 8, 3, 5]
total = 0

for i in my_list:
    total += i

print(total)


```
  
Что происходит?

* инструкция `for` определяет переменную, используемую для просмотра списка (здесь `i`), за которой следует ключевое слово `in` и название обрабатываемого списка (`my_list`)
* переменной `i` присваиваются значения всех последующих элементов списка, и процесс происходит столько раз, сколько элементов в списке;
* это означает, что Вы используете переменную `i` как копию значений элементов, и вам не нужно использовать индексы;
* функция `len()` здесь также не нужна


## Списки в действии

Давайте ненадолго оставим списки в стороне и рассмотрим одну интригующую проблему.

Представьте, что вам нужно переставить элементы списка, то есть поменять местами элементы в обратном порядке: первый и пятый, а также второй и четвертый элементы поменяются местами. Третий останется нетронутым.

  

Вопрос: как можно поменять местами значения двух переменных?

Взгляните на фрагмент кода:

```python
variable_1 = 1
variable_2 = 2

variable_2 = variable_1
variable_1 = variable_2

```  

Если вы сделаете что-то подобное, вы **потеряете значение, ранее сохраненное** в `variable_2`. Изменение порядка выполнения заданий не поможет. Вам понадобится **третья переменная, которая служит вспомогательной памятью**.

Вот как это можно сделать:

```
variable_1 = 1
variable_2 = 2

[!mark!]auxiliary[!/mark!] = variable_1
variable_1 = variable_2
variable_2 = [!mark!]auxiliary[!/mark!]
```  

Python предлагает более удобный способ перестановки - взгляните:

```python
variable_1 = 1
variable_2 = 2

variable_1, variable_2 = variable_2, variable_1
```  

Понятно, эффектно и элегантно - не правда ли?

Теперь вы можете легко **поменять местами** элементы списка, чтобы **изменить их порядок**:

```python
my_list = [10, 1, 8, 3, 5]

my_list [0], my_list [4] = my_list [4], my_list [0]
my_list [1], my_list [3] = my_list [3], my_list [1]

print(my_list)
```  

Запустите код. Его результат должен выглядеть так:

`[5, 3, 8, 1, 10]`

Прекрасно смотрится с пятью элементами.

Будет ли это приемлемо со списком из 100 элементов? Нет, не будет.

Можно ли использовать цикл `for` для автоматического выполнения того же самого, независимо от длины списка? Да, можно.

Вот как мы это сделали:

```
my_list = [10, 1, 8, 3, 5]
length = len(my_list)

[!mark!]for i in range(length // 2):
    my_list [i], my_list [length - i - 1] = my_list [length - i - 1], my_list [i][!/mark!]

print(my_list)
```

Примечание:

* мы присвоили переменной `length` длину текущего списка (это делает наш код немного чище и короче)
* мы запустили цикл `for` для прохождения его тела `length // 2` раз (это хорошо работает для списков как с четной, так и с нечетной длиной, потому что когда список содержит нечетное количество элементов, элемент в середине списка остается нетронутым)
* мы заменили i-й (с начала списка) элемент на элемент с индексом, равным `(length - i - 1)` (с конца списка); в нашем примере для `i`, равного `0`, `(length - i - 1)` дает `4`; для `i`, равного `1`, это дает `3` - это именно то, что нам нужно.

Списки чрезвычайно полезны, и вы будете встречать их очень часто.

  
## Основные тезисы

1. **Список - это тип данных** в Python, используемый для **хранения нескольких объектов**. Это **упорядоченный и изменяемый набор** элементов, разделенных запятыми в квадратных скобках, например:

    ```python
    my_list = [1, None, True, "I am a string", 256, 0]
    ```  

2. Списки можно **индексировать и обновлять**, например:

    ```python
    my_list = [1, None, True, "I am a string", 256, 0]
    print (my_list [3]) # outputs: O am a string
    print (my_list [-1]) # outputs: 0
    
    my_list [1] = '?'
    print(my_list) # outputs: [1, '?', True, "I am a string", 256, 0]
    
    my_list.insert(0, "first")
    my_list.append ("last")
    print (my_list) # outputs: ['first', 1, '?', True, "I am a string", 256, 0, 'last']
    
    ```  

3. Списки могут быть **вложенными**, например:

    ```python
    my_list = [1, 'a', ["list", 64, [0, 1], False]]
    ```  
    
    Вы узнаете больше о вложении в следующих модулях - пока мы просто хотим, чтобы вы знали, что нечто подобное тоже возможно.

4. Элементы списка и списки можно **удалить**, например:

   ```python
   my_list = [1, 2, 3, 4]
   del my_list[2]
   print(my_list) # outputs: [1, 2, 4]
   
   del my_list # deletes the whole list
   
   ```  
   
   Опять же, вы узнаете об этом больше в следующих модулях - не волнуйтесь. А пока просто попробуйте поэкспериментировать с приведенным выше кодом и проверьте, как его изменение влияет на результат.

5. По спискам можно **итерироваться** с помощью цикла `for`, например:

   ```python
   my_list = ["white", "purple", "blue", "yellow", "green"]
   
   for color in my_list:
       print(color)
   
   ```  

6. Функцию `len()` можно использовать для **проверки длины списка**, например:

```python
my_list = ["white", "purple", "blue", "yellow", "green"]
print(len(my_list)) # outputs 5

del my_list[2]
print (len (my_list)) # outputs 4

```  

7. Типичный вызов **функции** выглядит следующим образом: `result = function(arg)`, а типичный вызов **метода** выглядит так: `result = data.method(arg)`.


**Упражнение 1**

Что выведет следующий фрагмент кода?

```python
lst = [1, 2, 3, 4, 5]
lst.insert (1, 6)
del lst [0]
lst.append (1)

print(lst)

```  

<details><summary>Проверка</summary>

```
[6, 2, 3, 4, 5, 1]
```

</details>

**Упражнение 2**

Что выведет следующий фрагмент кода?

```python
lst = [1, 2, 3, 4, 5]
lst_2 = []
add = 0

for number in lst:
    add += number
    lst_2.append(add)

print(lst_2)

```  

<details><summary>Проверка</summary>

```
[1, 3, 6, 10, 15]
```

</details>

**Упражнение 3**

Что произойдет, когда вы запустите следующий фрагмент кода?

```python
lst = []
del lst
print(lst)

```  

<details><summary>Проверка</summary>

```
[!mark!]NameError: name 'lst' is not defined[!/mark!]
```

</details>

**Упражнение 4**

Что выведет следующий фрагмент кода?

```python
lst = [1, [2, 3], 4]
print(lst[1])
print(len(lst))

```  

<details><summary>Проверка</summary>

```
[2, 3]
3
```

</details>

