## Функции и области видимости

Начнем с определения:

**Область видимости имени** (например, имени переменной) - это часть кода, в которой имя распознается должным образом.

Например, областью видимости параметра функции является сама функция. Параметр недоступен вне функции.

Давайте проверим. Посмотрите на код. Что произойдет, когда Вы его запустите?

```python
def scope_test():
    x = 123


scope_test()
print(x)

```

Программа завершится ошибкой при запуске. Сообщение об ошибке будет гласить:

`NameError: name 'x' is not defined`

Этого следовало ожидать.

Мы собираемся провести с Вами несколько экспериментов, чтобы показать Вам, как Python создает области видимости и как Вы можете использовать их в своих интересах.

Начнем с проверки, видна ли внутри функции переменная, созданная вне какой-либо функции. Другими словами, распространяется ли имя переменной в тело функции?

Посмотрите код. Наша морская свинка тут.

```python
def my_function():
    print("Do I know that variable?", var)


var = 1
my_function()
print(var)

```

Результат проверки положительный - код выводит:

```
Do I know that variable? 1
1
```

Ответ: **переменная, существующая вне функции, имеет область видимости внутри тела функции**.

Из этого правила есть очень важное исключение. Попробуем его найти.

Внесем небольшие изменения в код:

```python
def my_function():
    [!mark!]var = 2[!/mark!]
    print("Do I know that variable?", var)


[!mark!]var = 1[!/mark!]
my_function()
print(var)

```  

Результат тоже изменился - теперь код выдаёт немного другой результат:

```
Do I know that variable? 2
1
```

Что произошло?

* переменная `var`, созданная внутри функции, отличается от той, которая была определена вне ее - кажется, что существуют две разные переменные с одинаковым именем;
* более того, переменная функции затеняет переменную, поступающую из внешнего мира.

Можем сделать предыдущее правило более точным и адекватным:

**Переменная, существующая вне функции, имеет область видимости внутри тела функции, кроме случая, когда функция определяет переменную с тем же именем.**

Это также означает, что **область видимости переменной, существующей вне функции, поддерживается только при получении ее значения** (при чтении). Присвоение значения приводит к созданию собственной переменной функции.

Убедитесь, что Вы хорошо это понимаете, и проведите собственные эксперименты.

  
## Функции и области видимости: ключевое слово global

Надеемся, теперь Вы должны прийти к следующему вопросу: означает ли это, что функция не может изменять переменную, определенную вне ее? Это создало бы сильный дискомфорт.

К счастью, ответ - _нет_.

Существует специальный метод Python, который может **расширить область видимости переменной, включив в нее тело функции** (даже если Вы хотите не только читать значения, но и изменять их).

Такой эффект вызывается ключевым словом с именем `global`:

```python
global name
global name1, name2, ...

```

Использование этого ключевого слова внутри функции с именем (или именами, разделенными запятыми) переменной (или переменных) заставляет Python воздерживаться от создания новой переменной внутри функции - вместо нее будет использоваться переменная, доступная извне.

Другими словами, это имя становится глобальным (оно имеет **глобальную область видимости**, и не имеет значения, является ли оно объектом чтения или записи).

Посмотрите на код.

```python
def my_function():
    global var
    var = 2
    print("Do I know that variable?", var)


var = 1
my_function()
print(var)

```

Мы добавили в функцию `global`.

Сейчас код выводит:

```
Do I know that variable? 2
2
```

Этого должно быть достаточно, чтобы показать, что ключевое слово `global` выполняет то, что обещает.


## Как функция взаимодействует со своими аргументами

Теперь давайте выясним, как функция взаимодействует со своими аргументами.

Представленный код должен Вас чему-то научить. Как видите, функция меняет значение своего параметра. Влияет ли это изменение на аргумент?

```python
def my_function(n):
    print("I got", n)
    n += 1
    print("I have", n)


var = 1
my_function(var)
print(var)
```


Запустите программу и проверьте.

Код выведет:

```
I got 1
I have 2
1
```

Вывод очевиден - **изменение значения параметра не распространяется за пределы функции** (во всяком случае, если переменная является скаляром, как в примере).

Это также означает, что функция получает **значение аргумента**, а не сам аргумент. Это верно для скаляров.

Стоит ли проверять, как это работает со списками (помните особенности срезов списков и присвоения списков целиком?).

Следующий пример проливает свет на проблему:

```python
def my_function(my_list_1):
    print("Print #1:", my_list_1)
    print("Print #2:", my_list_2)
    my_list_1 = [0, 1]
    print("Print #3:", my_list_1)
    print("Print #4:", my_list_2)


my_list_2 = [2, 3]
my_function(my_list_2)
print("Print #5:", my_list_2)

```

Код выведет:

```
Print #1: [2, 3]
Print #2: [2, 3]
Print #3: [0, 1]
Print #4: [2, 3]
Print #5: [2, 3]
```

Кажется, что прежнее правило все еще работает.

Наконец, видите ли Вы разницу в приведенном ниже примере:

```python
def my_function(my_list_1):
    print("Print #1:", my_list_1)
    print("Print #2:", my_list_2)
    del my_list_1[0]  # Pay attention to this line.
    print("Print #3:", my_list_1)
    print("Print #4:", my_list_2)


my_list_2 = [2, 3]
my_function(my_list_2)
print("Print #5:", my_list_2)

```  

Мы не меняем значение параметра `my_list_1` (мы уже знаем, что это не повлияет на аргумент), а вместо этого изменяем идентифицированный им список.

Результат может быть неожиданным. Запустите код и проверьте:

```
Print #1: [2, 3]
Print #2: [2, 3]
Print #3: [3]
Print #4: [3]
Print #5: [3]
```

Вы можете это объяснить?

Давайте попробуем:

* если аргумент является списком, то изменение значения соответствующего параметра не влияет на список (помните: переменные, содержащие списки, хранятся иначе, чем скаляры)
* но если вы измените список, идентифицированный параметром (обратите внимание: список, а не параметр!), изменение отобразится на списке.

Пришло время написать несколько примеров функций. Вы сделаете это в следующем разделе.

  
## Основные тезисы

1. Переменная, которая существует вне функции, имеет область видимости внутри тела функции (Пример 1), если только функция не определяет переменную с тем же именем (Пример 2 и Пример 3), например:

    Пример 1:
    
    ```python
    [!mark!]var = 2[!/mark!]
    
    
    def mult_by_var(x):
        return x * [!mark!]var[!/mark!]
    
    
    print(mult_by_var(7))    # outputs: 14
    
    ```  
    
    Пример 2:
    
    ```python
    def mult(x):
        [!mark!]var = 5[!/mark!]
        return x * [!mark!]var[!/mark!]
    
    
    print(mult(7))    # outputs: 35
    
    ```  
    
    Пример 3:
    
    ```python
    def mult(x):
        [!mark!]var = 7[!/mark!]
        return x * [!mark!]var[!/mark!]
    
    
    [!mark!]var = 3[!/mark!]
    print(mult(7))    # outputs: 49
    
    ```  

2. Переменная, которая существует внутри функции, имеет область видимости внутри тела функции (Пример 4), например:

    Пример 4:
    
    ```python
    def adding(x):
        var = 7
        return x + var
    
    
    print(adding(4))    # outputs: 11
    [!mark!]print(var)    # NameError[!/mark!]
    
    ```  

3. Вы можете использовать ключевое слово `global`, за которым следует имя переменной, чтобы сделать область видимости переменной глобальной, например:
    
    ```python
    var = 2
    print(var)    # outputs: 2
    
    
    def return_var():
        global var
        var = 5
        return var
    
    
    print(return_var())    # outputs: 5
    print(var)    # outputs: 5
    
    ```  
  
**Упражнение 1**

Что произойдет, когда Вы попытаетесь запустить следующий код?

```python
def message():
    alt = 1
    print("Hello, World!")


print(alt)

```  

<details><summary>Проверка</summary>

The `NameError` exception will be thrown (`NameError: name 'alt' is not defined`)

</details>

**Упражнение 2**

Что выведет следующий код?

```python
a = 1


def fun():
    a = 2
    print(a)


fun()
print(a)

```  

<details><summary>Проверка</summary>

`2 1`

</details>

**Упражнение 3**

Что выведет следующий код?

```python
a = 1


def fun():
    global a
    a = 2
    print(a)


fun()
a = 3
print(a)

```  

<details><summary>Проверка</summary>

`2 3`

</details>

**Упражнение 4**

Что выведет следующий код?

```python
a = 1


def fun():
    global a
    a = 2
    print(a)


a = 3
fun()
print(a)

```  

<details><summary>Проверка</summary>

`2 2`

</details>

